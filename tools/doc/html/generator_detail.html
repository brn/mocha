h2. Generator

h3. "index":index.html > "ES Next":es_next_detail.html > Generator

コルーチンを定義する拡張です。

*実装済み処理系* : Mozilla1.7以降

この機能は動作が複雑なので、わかりやすくするために、伝統的なフィボナッチ数の計算を行なってみます。

<notextile>
<pre class="brush: js">
//通常のjavascript
function doCallback(num) {
  console.log(num + "\n");
}
function fib() {
  var i = 0, j = 1, n = 0;
  while (n < 10) {
    doCallback(i);
    var t = i;
    i = j;
    j += t;
    n++;
  }
}
fib();
//generatorを使用すると...
function fib() {
  var i = 0, j = 1;
  while (true) {
    yield i;
    var t = i;
    i = j;
    j += t;
  }
}
var g = fib();
for (var i = 0; i < 10; i++) {
  console.log(g.next() + "\n");
}
</pre>
</notextile>

詳細な説明はMDNから引用します。

bq. yield キーワードを含む関数がジェネレータです。これを呼ぶと、ジェネレータの仮引数は実引数と結び付きますが、本体は実際には評価されません。代わりにジェネレータ・イテレータが返ってきます。ジェネレータ・イテレータの next() メソッドを呼び出すたびに、繰り返しのアルゴリズムが 1 回ずつ実行されます。それぞれのステップでの値は、yield キーワードで指定された値です。yield をアルゴリズムの繰り返しの範囲を示すジェネレータ・イテレータ版の return だと考えましょう。毎回 next() を呼び出すたび、ジェネレータのコードは yield の次の文から再開します。
あなたはジェネレータ・イテレータを、その next() メソッドを繰り返し呼び出すことで、あなたが望んだ結果の状態にたどりつくまで反復させられます。この例では、私たちが欲しいだけの結果を手に入れるまで g.next() を呼び出し続けることで、私たちはどれだけでも多くのフィボナッチ数を得ることができます。
"MDN Generator":https://developer.mozilla.org/ja/New_in_JavaScript_1.7#.E3.82.B8.E3.82.A7.E3.83.8D.E3.83.AC.E3.83.BC.E3.82.BF

簡単に説明すると関数をyieldキーワードの位置で一時停止し、二回目以降はその場所から実行を再開します。
またnextだけではなく、yieldに対して、値を与えられるsendメソッドもあります。
以下MDN

bq. 一度 next() メソッドを呼び出してジェネレータをスタートさせると、与えた特定の値を最後の yield の結果として扱わせる send() を使うことができます。その際ジェネレータはその次の yield のオペランドを返します。
ジェネレータを勝手な時点から始めることはできません。特定の値を send() する前に必ず next() でジェネレータをスタートさせなければなりません。
"MDN Generator":https://developer.mozilla.org/ja/New_in_JavaScript_1.7#.E3.82.B8.E3.82.A7.E3.83.8D.E3.83.AC.E3.83.BC.E3.82.BF

*send*
<notextile>
<pre class="brush: js">
yieldTest()-> {
  for ( var i = 0;i<10; i++ ) {
    var m = yield i;
    if ( m === true ) {
      yield i + 1;
    } else if ( m === false ){
      yield i - 1;
    } else {
      yield i;
    }
  }
}
generator = yieldTest();
@assert( true , generator.next() === 0 );
@assert( true , generator.send( true ) === 1 );
@assert( true , generator.send( false ) === 1 );
@assert( true , generator.send( true ) === 2 );
@assert( true , generator.send( false ) === 2 );
@assert( true , generator.send( true ) === 3 );
@assert( true , generator.send( true ) === 3 );
@assert( true , generator.send( true ) === 4 );
@assert( true , generator.send( false ) === 4 );
@assert( true , generator.send( true ) === 5 );
</pre>
</notextile>

このようにsendに値を与えると、<code>yield i</code> の部分が引数に置き換わります。


*iterator*

イテレータとはオブジェクトに独自の列挙方法を与える機能です。

<notextile>
<pre class="brush: js">
import {iterator} from "iterators";
var iter = {
      arr : [],
      add : function ( value ) {
        this.arr.push( value );
      },
      [iterator] : function () {
        var arr = this.arr;
        return {
          index : 0,
          next : function () {
            if ( arr.length > this.index ) {
              var ret = arr[ this.index ];
              this.index++;
              return ret;
            } else {
              throw StopIteration;
            }
          }
        }
      }
    }
</pre>
</notextile>

この例のように、iteratorを生成するにはiteratorsモジュールのiteratorの値を、objectのプロパティにする必要があります。
ここで定義したiteratorはES Nextで追加されたfor of構文で使用されます。
詳しくは"for of":for_of_detail.htmlを参照してください。

