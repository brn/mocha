h2. class

h3. "index":index.html > "ES Next":es_next_detail.html > class

class定義です。

現在策定されているプロポーサルではclassが組み込まれる予定です。
class機能自体はfunctionの糖衣構文になります。

*実装済み処理系* : 無し

h4. Example

まずは今までの書き方でクラスを生成してみます。

<notextile>
<pre class="brush: js">
//このクラスはTHREE.Meshを継承しています。
function SkinnedMesh(geometry, materials) {
  //親クラスのコンストラクタを呼び出します。
  THREE.Mesh.call(this, geometry, materials); 
  this.identityMatrix = new THREE.Matrix4();
  this.bones = [];
  this.boneMatrices = [];
};
//ecmascript5以降での継承です。
//THREE.Mesh.prototypeを継承したprototypeオブジェクトを生成します。
SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);
SkinnedMesh.prototype.constructor = SkinnedMesh;
SkinnedMesh.prototype.update = function(camera) {
  //親クラスのupdateメソッドの呼び出し。
  THREE.Mesh.prototype.update.call(this);
};
</pre>
</notextile>

es nextで予定されているclassを使って書き換えてみます。

<notextile>
<pre class="brush: js">
//継承を行うためにはclass 'drived' extends 'super'という構文を使う
//superはコンストラクタ関数か、クラスである必要がある
class SkinnedMesh extends THREE.Mesh {
  constructor(geometry, materials) {
    //親クラスのコンストラクタを呼び出す。
    //THREE.Mesh.call(this, geometry, materials)に該当
    super(geometry, materials);
    //publicなメンバはすべてpublic修飾子を宣言の前に付与する
    public identityMatrix = new THREE.Matrix4();
    public bones = [];
    public boneMatrices = [];
    ...
  }
  update(camera) {
    ...
    //親クラスのメソッド呼び出し。
    //THREE.Mesh.prototype.update.call(this)に該当
    super.update();
  }
}
</pre>
</notextile>

基本的な書き方を提示します。

<notextile>
<pre class="brush: js">
class Monster {
  //コンストラクタは以下のように定義します。
  //クラスのメンバはコンストラクタ内で指定します。
  constructor(name, health) {
    public name = name;
    private health = health;
  }
  //クラスのメソッドはpublicかprivateのアクセス修飾が可能です。
  //指定しない場合はprivateになります。
  public attack(target) {
    log('The monster attacks ' + target);
  }
  //省略関数も利用可能です。
  //private修飾は本来の提案だとprivate(this).value
  //という形なのですが、無駄が多いので、一旦この形になっています。
  public isAlive -> private.health > 0;
  public health(value) {
    if (value < 0) {
      throw new Error('Health must be non-negative.')
    }
    private.health = value
  }
  //publicな関数以外のメンバはprototypenに設定され、
  //全てのインスタンスで共通の値が使用されます。
  public numAttacks = 0;
  //constなメンバはコンストラクタか、定義時に初期化しなければ
  //値の追加はできません。
  public const attackMessage = 'The monster hits you!';
  //static修飾が宣言されると変数はstaticな変数になります。
  //static修飾にはprivate,publicは設定できません。
  static const DEFAULT_LIFE = 100;
}
</pre>
</notextile>

mochaによる変換後のスクリプトです。

<notextile>
<pre class="brush: js">
var Monster = function () {
      function constructor(name,health) {
        this.name = name;
        Runtime.getPrivateRecord(this).health = health;
      }
      function Monster() {
        Runtime.initializeClass(this, Monster, _mochaPrivateHolder, constructor, arguments, "Monster", 1);
      }
      var _mochaPrivateHolder = function (){};
      
      Runtime.createUnenumProp(constructor,"__harmony_class__",1);
      
      Monster.prototype.attack = function (target) {
        log('The monster attacks '+target);
      };
      
      Monster.prototype.isAlive = function () {
        return Runtime.getPrivateRecord(this).health>0;
      };
      
      Monster.prototype.health = function (value) {
        if (value<0)throw new Error('Health must be non-negative.')
        
        Runtime.getPrivateRecord(this).health = value;
      };
      
      Monster.prototype.numAttacks = 0;
      
      Runtime.constant(Monster.prototype,'attackMessage','The monster hits you!');
      
      Runtime.constant(Monster,'DEFAULT_LIFE',100);
      
      Runtime.createUnenumProp(Monster.prototype,"constructor",constructor);
      return Monster;
    }()
</pre>
</notextile>

h4. Detail

mochaではclassはコンストラクタ関数と、プロトタイプの糖衣構文として機能します。なので、既存のjavascriptのクラスと100%の互換性を持っています。
またクラスを使用することによるオーバーヘッドもできるだけ抑えてありますが、privateフィールドの実現のためにやや実行時にオーバーヘッドがあります。

以下が詳細な構文です。

h5. 宣言

_const_(optional) _class_ *&lt;class name&gt;* _extends_ or _prototype_ *&lt;base class name or literal&gt;*
　
クラスを宣言します。class nameとbase class nameはjavascriptで使用可能な変数名を使用可能です。
const修飾子がついていた場合は、すべてのメンバが変更不可能になります。
継承の際にextendsを選ぶと、通常のプロトタイプの継承になります。prototypeを選ぶと、直接&lt;base class name or literal&gt;をprototypeとして使用します。
　
　
_constructor( *&lt;arguments list&gt;* )_ *&lt;function body&gt;*
　
コンストラクタを定義します。コンストラクタは必ずconstructorという関数名でなければなりません。
メンバ変数の初期化を行います。コンストラクタが定義されていなければ、mochaが自動で空のコンストラクタを生成します。
　

_const_(optional) _public_ _or_ _private_ or _static_ *&lt;name&gt;* *&lt;function body or '=' values&gt;*(optional)

メンバを定義します。public修飾子がついていた場合はメンバは外部からアクセス可能になります。
const修飾子がついていた場合は、メンバは変更不可能になります。
private修飾子がついていた場合は、外部からアクセス不可なメンバになります。
何も修飾子を付けなかった場合は、デフォルトでprivateになります。
static修飾子が宣言された場合はメンバはインスタンス無しにアクセス可能になりますが、static以外のメンバにはアクセス出来ません。
またstaticなメンバはprivate、publicといったアクセス修飾は現在は出来ません。
　
this. *&lt;name&gt;*

publicメンバにアクセスします。
　　
private(object).*&lt;name&gt;*

privateメンバにアクセスします。
