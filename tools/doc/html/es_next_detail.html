<div class="titile">
    <h2>Grammar Reference</h2>
</div>
<div class="row">
    <div class="span4">
	<div class="tabbable tabs-left">
	    <ul class="nav nav-tabs grammar_list">
		<li class="active"><a data-toggle="tab" href="#class">class</a></li>
		<li><a data-toggle="tab" href="#trait">trait</a></li>
		<li><a data-toggle="tab" href="#destructuring-assignment">destructuring assignment</a></li>
		<li><a data-toggle="tab" href="#for-each">for each</a></li>
		<li><a data-toggle="tab" href="#do-expression">do expressions</a></li>
		<li><a data-toggle="tab" href="#short-function-syntax">short function syntax</a></li>
		<li><a data-toggle="tab" href="#import">import</a></li>
		<li><a data-toggle="tab" href="#module">module</a></li>
		<li><a data-toggle="tab" href="#let-expression">let expression</a></li>
		<li><a data-toggle="tab" href="#object-literal-extras">object literal extras</a></li>
		<li><a data-toggle="tab" href="#data-structure-extras">data structur extras</a></li>
		<li><a data-toggle="tab" href="#generator-iterator">generator/iterator</a></li>
		<li><a data-toggle="tab" href="#for-of">for of</a></li>
	    </ul>
	</div>
</div>
<div class="span8">
    <div class="tab-content">
	<div id="class" class="tab-pane active">
	    <h3>class</h3>
	    <p>現在策定されているプロポーサルではclassが組み込まれる予定です。
		class機能自体はfunctionの糖衣構文になります。</p>
	    <p>実装済み処理系 : 無し</p>
	    <div>
		<p>まずは今までの書き方でクラスを生成してみます。</p>
		<pre class="prettyprint grammars"><code>//このクラスはTHREE.Meshを継承しています。
function SkinnedMesh(geometry, materials) {
  //親クラスのコンストラクタを呼び出します。
  THREE.Mesh.call(this, geometry, materials); 
  this.identityMatrix = new THREE.Matrix4();
  this.bones = [];
  this.boneMatrices = [];
};

//ecmascript5以降での継承です。
//THREE.Mesh.prototypeを継承したprototypeオブジェクトを生成します。
SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);
SkinnedMesh.prototype.constructor = SkinnedMesh;
SkinnedMesh.prototype.update = function(camera) {
  //親クラスのupdateメソッドの呼び出し。
  THREE.Mesh.prototype.update.call(this);
};</code></pre>
	    <p>次にES Nextで予定されているclassを使って書き換えてみます。</p>
	    <pre class="prettyprint grammars"><code>//継承を行うためにはclass 'drived' extends 'super'という構文を使う
//superはコンストラクタ関数か、クラスである必要がある
class SkinnedMesh extends THREE.Mesh {
  constructor(geometry, materials) {
    //親クラスのコンストラクタを呼び出す。
    //THREE.Mesh.call(this, geometry, materials)に該当
    super(geometry, materials);
    //publicなメンバはすべてpublic修飾子を宣言の前に付与する
    public identityMatrix = new THREE.Matrix4();
    public bones = [];
    public boneMatrices = [];
    ...
  }
  update(camera) {
    ...
    //親クラスのメソッド呼び出し。
    //THREE.Mesh.prototype.update.call(this)に該当
    super.update();
  }
}</code></pre>
		<p>次に基本的なクラスの構成要素の説明をします。</p>
		<pre class="prettyprint grammars"><code>class Monster {
  //コンストラクタは以下のように定義します。
  //クラスのメンバはコンストラクタ内で指定します。
  constructor(name, health) {
    public name = name;
    private health = health;
  }
  //クラスのメソッドはpublicかprivateのアクセス修飾が可能です。
  //指定しない場合はprivateになります。
  public attack(target) {
    log('The monster attacks ' + target);
  }
  //省略関数も利用可能です。
  //private修飾は本来の提案だとprivate(this).value
  //という形なのですが、無駄が多いので、一旦この形になっています。
  public isAlive -> private.health > 0;
  public health(value) {
    if (value < 0) {
      throw new Error('Health must be non-negative.')
    }
    private.health = value
  }
  //publicな関数以外のメンバはprototypenに設定され、
  //全てのインスタンスで共通の値が使用されます。
  public numAttacks = 0;
  //constなメンバはコンストラクタか、定義時に初期化しなければ
  //値の追加はできません。
  public const attackMessage = 'The monster hits you!';
  //static修飾が宣言されると変数はstaticな変数になります。
  //static修飾にはprivate,publicは設定できません。
  static const DEFAULT_LIFE = 100;
}</code></pre>
		<p>変換後は以下のようになります。</p>
		<pre class="prettyprint grammars"><code>var Monster = function () {
      function constructor(name,health) {
        this.name = name;
        Runtime.getPrivateRecord(this).health = health;
      }
      function Monster() {
        Runtime.initializeClass(this, Monster, _mochaPrivateHolder, constructor, arguments, "Monster", 1);
      }
      var _mochaPrivateHolder = function (){};
      
      Runtime.createUnenumProp(constructor,"__harmony_class__",1);
      
      Monster.prototype.attack = function (target) {
        log('The monster attacks '+target);
      };
      
      Monster.prototype.isAlive = function () {
        return Runtime.getPrivateRecord(this).health>0;
      };
      
      Monster.prototype.health = function (value) {
        if (value<0)throw new Error('Health must be non-negative.')
        
        Runtime.getPrivateRecord(this).health = value;
      };
      
      Monster.prototype.numAttacks = 0;
      
      Runtime.constant(Monster.prototype,'attackMessage','The monster hits you!');
      
      Runtime.constant(Monster,'DEFAULT_LIFE',100);
      
      Runtime.createUnenumProp(Monster.prototype,"constructor",constructor);
      return Monster;
    }()</code></pre>
			  <div class="section">
			      <p class="title">詳細</p>
			      <p>mochaではclassはコンストラクタ関数と、プロトタイプの糖衣構文として機能します。なので、既存のjavascriptのクラスと100%の互換性を持っています。またクラスを使用することによるオーバーヘッドもできるだけ抑えてありますが、privateフィールドの実現のためにやや実行時にオーバーヘッドがあります。</p>
			  </div>
			  <div class="section">
			      <p class="title">インターフェース</p>
			      <pre class="prettyprint grammars"><code><i>const(optional)</i> <i>class</i> &lt;class name&gt; <i>extends or prototype</i> &lt;base class name or literal&gt;</code></pre>
			      <p>
				  クラスを宣言します。class nameとbase class nameはjavascriptで使用可能な変数名を使用可能です。
		    const修飾子がついていた場合は、すべてのメンバが変更不可能になります。
		    継承の際にextendsを選ぶと、通常のプロトタイプの継承になります。prototypeを選ぶと、直接&lt;base class name or literal&gt;をprototypeとして使用します。
			      </p>
			      <pre class="prettyprint grammars"><code><i>constructor(</i>&lt;arguments list&gt;<i>)</i> &lt;function body&gt;</code></pre>
			      <p>
				  コンストラクタを定義します。コンストラクタは必ずconstructorという関数名でなければなりません。
				  メンバ変数の初期化を行います。コンストラクタが定義されていなければ、mochaが自動で空のコンストラクタを生成します。
			      </p>

			      <pre class="prettyprint grammars"><code><i>const(optional)</i> <i>public or private or static</i> &lt;name&gt; &lt;function body or '=' values&gt;(optional)</code></pre>
			      <p>
				  メンバを定義します。public修飾子がついていた場合はメンバは外部からアクセス可能になります。
				  const修飾子がついていた場合は、メンバは変更不可能になります。
				  private修飾子がついていた場合は、外部からアクセス不可なメンバになります。
				  何も修飾子を付けなかった場合は、デフォルトでprivateになります。
				  static修飾子が宣言された場合はメンバはインスタンス無しにアクセス可能になりますが、static以外のメンバにはアクセス出来ません。
				  またstaticなメンバはprivate、publicといったアクセス修飾は現在は出来ません。
			      </p>
			      <pre class="prettyprint grammars"><code><i>this.</i>&lt;name&gt;</code></pre>
			      <p>publicメンバにアクセスします。</p>
			      <pre class="prettyprint grammars"><code><i>private(object).</i>&lt;name&gt;</code></pre>
			      <p>privateメンバにアクセスします。</p>
			  </div>
	    </div>
	</div>
	<div id="trait" class="tab-pane">
	    <h3>trait</h3>
	    <p>クラスの振る舞いのみを定義したオブジェクトです。</p>
	    <p>実装済み処理系 : 無し</p>
	    <div>
		<p>traitの定義は以下のように行います。</p>
		<pre class="prettyprint grammars"><code>//traitの定義
trait TestTrait {
  requires testReq1;
  public test1( ...arg )->this.testReq1(arg[0]);
}
trait TestTrait2 {
  requires testReq2;
  public test1( ...arg )->this.testReq2(arg[0]);
  public test2->console.log('ok');
}
class MixinTest {
  public testReq1(arg) -> console.log(arg);
  public testReq2(arg) -> console.log(arg);
  mixin TestTrait with test1 as method1;
  mixin TestTrait2 without test1, with test2 as method2;
}</code></pre>
		<p>変換後は以下のようになります。</p>
		<pre class="prettyprint grammars"><code>var TestTrait =  {
        _mochaTraitPrivate : {},
        _mochaTraitPublic :  {
          test1 : function testm1() {
            var arg = Runtime.toArray(arguments,0);
            this.testReq1(arg[0]);
          }
        },
        _mochaRequires :  {
          testReq1 : true
        },
        _mochaTraitMark : true
      },
      TestTrait2 =  {
        _mochaTraitPrivate : {},
        _mochaTraitPublic :  {
          test1 : function testm2() {
            var arg = Runtime.toArray(arguments,0);
            this.testReq2(arg[0]);
          },
          test2 : function testm3() {
            console.log('ok');
          }
        },
        _mochaRequires :  {
          testReq2 : true
        },
        _mochaTraitMark : true
      },
      MixinTest = function () {
        function constructor(){}
        function MixinTest() {
          Runtime.initializeClass(this,MixinTest,_mochaPrivateHolder,constructor,arguments,'MixinTest',101);
        }
        var _mochaPrivateHolder = function (){};
        Runtime.createUnenumProp(constructor,"__harmony_class__",1);
        MixinTest.prototype.testReq1 = function (arg) {
          return console.log(arg)
        };
        MixinTest.prototype.testReq2 = function (arg) {
          return console.log(arg)
        };
        Runtime.classMixin(MixinTest,_mochaPrivateHolder,TestTrait, {
          test1 : "method1"
        },{});
        Runtime.classMixin(MixinTest,_mochaPrivateHolder,TestTrait2,{
          test2 : "method2"
        }, {
          test1 : true
        });
        Runtime.checkRequirements(MixinTest,_mochaPrivateHolder,[TestTrait,TestTrait2],'class_test.js',105);
        Runtime.createUnenumProp(MixinTest.prototype,"constructor",constructor);
        return MixinTest;
   }()</code></pre>
		<div class="section">
		    <p class="title">詳細</p>
		    <p>クラスに対して振る舞いを注入します。traitはrequireプロパティを設定することで実装しなければならないメソッドを指定できます。
またmixin属性を設定することで、trait同士、あるいはclassとtraitを合成可能です。その際にmixin ... with &lt;method_name&gt; as &lt:new_name&gt;とすることでメソッド名の書き換えが可能です。またwithout属性を指定することで、特定のメソッドのmixinを無効化することが可能です。
public,privateなどの指定はclassを参照してください。</p>
		</div>
		<div class="section">
		    <p class="title">インターフェース</p>
		    <pre class="prettyprint grammars"><code><i>trait</i> &lt;trait name&gt;</code></pre>
		    <p>traitを宣言します。</p>
		    <pre class="prettyprint grammars"><code><i>mixin</i> &lt;trait name&gt; <i>with(optional)</i> &lt;member name&gt; <i>as</i> &lt;new member name&gt <i>without(optional)</i> &lt;member name&gt;</code></pre>
		</div>
	    </div>
	</div>
	<div id="destructuring-assignment" class="tab-pane">
	    <h3>destructuring assignment</h3>
	    <p>分割代入機能です。</p>
	    <p>実装済み処理系 : mozilla 1.6以降</p>
	    <div>
		<p>配列</p>
		<pre class="prettyprint grammars"><code>var array = [0,1,2,3],
    [one,two,three,four] = array;
console.log(one,two,three,four);</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>var array = [0,1,2,3],
    one = array[0],
    two = array[1],
    three = array[2],
    four = array[3]</code></pre>
		<p>オブジェクト</p>
		<pre class="prettyprint grammars"><code>var obj = {
      one : 0,
      two : 1,
      three : 2,
      four : 3
    },
    {one,two,three,four} = obj;</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>var obj = {
      one : 0,
      two : 1,
      three : 2,
      four : 3
    },
    one = obj.one,
    two = obj.two,
    three = obj.three,
    four = obj.four;</code></pre>
		<p>少々複雑な例</p>
		<pre class="prettyprint grammars"><code>var object = {
      value1 : 100,
      value2 : {
        value3 : 100
      },
      value4 : [100,200,300],
      value5 : {
        value6 : [{value7 : 100}]
      },
      "@value" : {
        strvalue : 100
      }
    }
var {value1,value2:{ value3 },value4 : [ value5_,value6_,value7_ ],value5 : { value6 : [{value7}] },"@value":{strvalue}} = object;
		</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>var object = {
      value1 : 100,
      value2 : {
        value3 : 100
      },
      value4 : [100,200,300],
      value5 : {
        value6 : [{value7 : 100}]
      },
      "@value" : {
        strvalue : 100
      }
    },
    value1 = object.value1,
    value3 = object.value2 && object.value2.value3?object.value2.value3 : undefined,
    value5_ = object.value4 && object.value4[0]?object.value4[0] : undefined,
    value6_ = object.value4 && object.value4[1]?object.value4[1] : undefined,
    value7_ = object.value4 && object.value4[2]?object.value4[2] : undefined,
    value7 = object.value5 && object.value5.value6 && object.value5.value6[0] && object.value5.value6[0].value7?object.value5.value6[0].value7 : undefined,
    strvalue = object["@value"] && object["@value"].strvalue?object["@value"].strvalue : undefined;</code></pre>
	    </div>
	</div>
	<div id="for-each" class="tab-pane">
	    <h3>for each</h3>
	    <p>for each構文です。</p>
	    <p>実装済み処理系 : mozilla 1.6以降</p>
	    <div>
		<pre class="prettyprint grammars"><code>var obj = {a:1,b:2}
for each(var i in obj) {
  console.log(i);
}</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>var obj = {a:1,b:2}
for(var i in obj) {
  i = obj[i];
  console.log(i);
}</code></pre>
	    </div>
	</div>
	<div id="do-expression" class="tab-pane">
	    <h3>do expression</h3>
	    <p>簡易スコープです。</p>
	    <p>実装済み処理系 : なし</p>
	    <div>
		<pre class="prettyprint grammars"><code>var x = do { var t = f(); t * t + 1 };</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>var x = function () {
    var t = f();
    return t * t + 1;
}();</code></pre>
	    </div>
	</div>
	<div id="short-function-syntax" class="tab-pane">
	    <h3>short function syntax</h3>
	    <p>関数の短縮構文です。</p>
	    <p>実装済み処理系 : なし</p>
	    <div>
		<p>無名関数</p>
		<pre class="prettyprint grammars"><code>var a = (x,y,z) -> x + y + z,
    b = (x,y,z) -> { return x + y + z; }</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>var a = function (x,y,z) { return x + y + z;},
    b = function (x,y,z) { return x + y + z;}</code></pre>
		<p>関数宣言</p>
		<pre class="prettyprint grammars"><code>foo(x,y,z) -> x + y + z;
bar(x,y,z) -> { return x + y + z; }</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>function foo (x,y,z) { return x + y + z;}
function bar (x,y,z) { return x + y + z;}</code></pre>
		<p>コンテキストの束縛</p>
		<pre class="prettyprint grammars"><code>var a = (x,y,z) => x + y + z,
    b = (x,y,z) => { return x + y + z; }
foo(x,y,z) => console.log(this);
bar(x,y,z) => {console.log(this) }</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>var a = function (x,y,z) { return x + y + z; }.bind(this),
    b = function (x,y,z) { return x + y + z; }.bind(this);
function foo (x,y,z) { return console.log(_mochaLocalTmp0);}
foo = foo.bind(this);
function bar (x,y,z) { return console.log(_mochaLocalTmp1);}
bar = bar.bind(this);</code></pre>
	    </div>
	</div>
	<div id="import" class="tab-pane">
	    <h3>import</h3>
	    <p>モジュールのインポート機能です。</p>
	    <p>実装済み処理系 : なし</p>
	    <div>
		<pre class="prettyprint grammars"><code>import module from './test';
import {exports1,exports2} from './test2'.module;
import [value1, value2] from './test3'.module.exports;
import exports from './test4'.module;
import './test5' as test5</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>var module = Runtime.modules.get('349045-test.js').module,
    _mochaLocalTmp0 = Runtime.modules.get('564059-test2.js').module,
    exports1 = _mochaLocalTmp0.exports1,
    exports2 = _mochaLocalTmp0.exports2,
    _mochaLocalTmp1 = Runtime.modules.get('906045-test3.js').module.exports,
    value1 = _mochaLocalTmp1[0],
    value2 = _mochaLocalTmp1[1],
    exports = Runtime.modules.get('945095-test4.js').module.exports,
    test5 = Runtime.modules.get('455905-test5.js');
    </code></pre>
		<div class="section">
		    <p class="title">詳細</p>
		    <p>importのルール</p>
		    <p>ファイルのインポートは以下のルールに沿って行われます。</p>
		    <table>
			<tr>
			    <th>記述</th><th>説明</th>
			</tr>
			<tr>
			    <td>'./filename'</td><td>現在のファイルがあるディレクトリから探します。</td>
			</tr>
			<tr>
			    <td>'filename'</td><td>ランタイムモジュール、あるいはoptionのmoduleDirプロパティから探します。</td>
			</tr>
		    </table>
		</div>
	    </div>
	</div>
	<div id="module" class="tab-pane">
	    <h3>module</h3>
	    <p>モジュール化機能です。</p>
	    <p>実装済み処理系 : なし</p>
	    <div>
		<pre class="prettyprint grammars"><code>module testModule {
  export test() -> console.log('test!!');
}
module testModule2 {
  module testInnerModule3 {
    export testExport2()->2;
    export testExport3 = {test:200};
  }
}
module testModule3 = ->3</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>var testModule = Runtime.modules.get('3490394-test.js').testModule = function () {
      function testExport1() {
        return console.log('test!!');
      }
      var _mochaLocalExport = {};
      _mochaLocalExport.testExport1 = testExport1;
      return _mochaLocalExport;
    }();
var testModule2 = Runtime.modules.get('3490394-test.js').testModule2 = function () {
  var _mochaLocalExport = {},
    testInnerModule3 = _mochaLocalExport.testInnerModule3 = function () {
      function testExport2() {
        return 2;
      }
      var _mochaLocalExport = {};
      _mochaLocalExport.testExport2 = testExport2;
      var testExport3 = _mochaLocalExport.testExport3 =  {
          test : 200
        };
      return _mochaLocalExport;
    }();
  return _mochaLocalExport;
}();
Runtime.modules.get('3490394-test.js').testModule3 = function () {
  return 3;
}</code></pre>
		<div class="section">
		    <p class="title">詳細</p>
		    <p>各モジュールはファイルスコープ直下にしか置けません。モジュールに指定した名前が直接エクスポートされます。</p>
		</div>
		<div class="section">
		    <p class="title">宣言</p>
		    <pre class="prettyprint grammars"><code><i>module</i> &lt;module name&gt; <i>{</i> ... <i>}</i></code></pre>
		    <p>moduleを宣言します。moduleはネスト可能です。ネストした場合は親のモジュール以下に設定されます。</p>
		    <pre class="prettyprint grammars"><code><i>module</i> &lt;module name&gt; <i>=</i> &lt;values&gt;</code></pre>
		    <p>直接値をエクスポートします。この構文でモジュールを宣言すると、'='で割り当てた値がmoduleの値になります。</p>
		</div>
	    </div>
	</div>
	<div id="let-expression" class="tab-pane">
	    <h3>let expression</h3>
	    <p>新しいスコープを生成します。</p>
	    <p>実装済み処理系 : mozilla1.7以降</p>
	    <div>
		<pre class="prettyprint grammars"><code>var foo = 200;
let (foo = 300) {
  console.assert(foo === 300);
}</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>var foo = 200;
!function(foo) {
  console.assert(foo === 300);
}(300);</code></pre>
		<div class="section">
		    <p class="title">詳細</p>
		    <p>スコープを生成します。let式の入り口に定義した値はlet式内のスコープでのみ有効になります。</p>
		</div>
	    </div>
	</div>
	<div id="object-literal-extras" class="tab-pane">
	    <h3>object literal extras</h3>
	    <p>オブジェクトリテラルの拡張構文です。</p>
	    <p>実装済み処理系 : なし</p>
	    <div>
		<p>batch assignment operator</p>
		<pre class="prettyprint grammars"><code>var namespaces = {
      foo : {},
      bar : {}
    }
namespaces.{
  baz : {}
}.{
  qux : {}
}</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>var namespaces = {
      foo : {},
      bar : {}
    }
Runtime.extend(Runtime.extend(namespaces, {
  bar : {}
}), {
  qux : {}
});</code></pre>
		<p>private property</p>
		<pre class="prettyprint grammars"><code>var foo = 'private_name';
var namespaces = {
      [foo] : {},
      bar : {}
    }</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>var foo = 'private_name';
var namespace = {
      bar : {}
    }
Runtime.createUnenumProp(namespace, 'foo', {});</code></pre>
	    </div>
	</div>
	<div id="data-structure-extras" class="tab-pane">
	    <h3>data structure extras</h3>
	    <p>データ構造の追加構文です。</p>
	    <p>実装済み処理系 : なし</p>
	    <div>
		<p>tuple</p>
		<pre class="prettyprint grammars"><code>var tuple = #[0,1,2,3];
var tuple2 = new Tuple(0,1,2,3);</code></pre>		
		<p>record</p>
		<pre class="prettyprint grammars"><code>var foo = #{"foo":0,"bar":1,"baz":2}
var bar = new Record({"foo":0,"bar":1,"baz":2});</code></pre>
		<div class="section">
		    <p class="title">詳細</p>
		    <p><strong>tuple</strong></p>
		    <p>tupleを生成します。tupleは配列に似た値の集合ですが、imutableな値であり、変更不可能です。</p>
		    <p><strong>API</strong></p>
		    <table>
			<tr>
			    <th>名前</th>
			    <th>インターフェース</th>
			    <th>説明</th>
			</tr>
			<tr>
			    <td>equal</td><td>equal(tuple)</td><td>２つのtupleを比較します。</td>
			</tr>
			<tr>
			    <td>toArray</td><td>toArray()</td><td>配列に変換します。</td>
			</tr>
			<tr>
			    <td>length</td><td>Number</td><td>tupleの長さを返します。</td>
			</tr>
		    </table>
		    <p><strong>record</strong></p>
		    <p>オブジェクトに似た連想配列を生成しますが、imutableであり、変更できません。</p>
		    <p>現在recordには特定のメソッドはありません。</p>
		</div>
	    </div>
	</div>
	<div id="generator-iterator" class="tab-pane">
	    <h3>generator/iterator</h3>
	    <p>コルーチンや、列挙子を定義する拡張です。</p>
	    <p>実装済み処理系 : なし</p>
	    <div>
		<pre class="prettyprint grammars"><code>//通常のjavascript
function doCallback(num) {
  console.log(num + "\n");
}
function fib() {
  var i = 0, j = 1, n = 0;
  while (n < 10) {
    doCallback(i);
    var t = i;
    i = j;
    j += t;
    n++;
  }
}
fib();
//generatorを使用すると...
function fib() {
  var i = 0, j = 1;
  while (true) {
    yield i;
    var t = i;
    i = j;
    j += t;
  }
}
var g = fib();
for (var i = 0; i < 10; i++) {
  console.log(g.next() + "\n");
}</code></pre>
		    <p>MDNからの引用</p>
		    <blockquote><p>yield キーワードを含む関数がジェネレータです。これを呼ぶと、ジェネレータの仮引数は実引数と結び付きますが、本体は実際には評価されません。代わりにジェネレータ・イテレータが返ってきます。ジェネレータ・イテレータの next() メソッドを呼び出すたびに、繰り返しのアルゴリズムが 1 回ずつ実行されます。それぞれのステップでの値は、yield キーワードで指定された値です。yield をアルゴリズムの繰り返しの範囲を示すジェネレータ・イテレータ版の return だと考えましょう。毎回 next() を呼び出すたび、ジェネレータのコードは yield の次の文から再開します。
あなたはジェネレータ・イテレータを、その next() メソッドを繰り返し呼び出すことで、あなたが望んだ結果の状態にたどりつくまで反復させられます。この例では、私たちが欲しいだけの結果を手に入れるまで g.next() を呼び出し続けることで、私たちはどれだけでも多くのフィボナッチ数を得ることができます。</p>
<small><a href="https://developer.mozilla.org/ja/New_in_JavaScript_1.7#.E3.82.B8.E3.82.A7.E3.83.8D.E3.83.AC.E3.83.BC.E3.82.BF">MDN Generator</a></small></blockquote>
		    <p>簡単に説明すると関数をyieldキーワードの位置で一時停止し、二回目以降はその場所から実行を再開します。
またnextだけではなく、yieldに対して、値を与えられるsendメソッドもあります。</p>
		    <p>MDN</p>
		    <blockquote><p>一度 next() メソッドを呼び出してジェネレータをスタートさせると、与えた特定の値を最後の yield の結果として扱わせる send() を使うことができます。その際ジェネレータはその次の yield のオペランドを返します。
ジェネレータを勝手な時点から始めることはできません。特定の値を send() する前に必ず next() でジェネレータをスタートさせなければなりません。</p>
<small><a href="https://developer.mozilla.org/ja/New_in_JavaScript_1.7#.E3.82.B8.E3.82.A7.E3.83.8D.E3.83.AC.E3.83.BC.E3.82.BF">MDN Generator</a></small></blockquote>
		    <p>sendの例</p>
		    <pre class="prettyprint grammars"><code>yieldTest()-> {
  for ( var i = 0;i<10; i++ ) {
    var m = yield i;
    if ( m === true ) {
      yield i + 1;
    } else if ( m === false ){
      yield i - 1;
    } else {
      yield i;
    }
  }
}
generator = yieldTest();
@assert( true , generator.next() === 0 );
@assert( true , generator.send( true ) === 1 );
@assert( true , generator.send( false ) === 1 );
@assert( true , generator.send( true ) === 2 );
@assert( true , generator.send( false ) === 2 );
@assert( true , generator.send( true ) === 3 );
@assert( true , generator.send( true ) === 3 );
@assert( true , generator.send( true ) === 4 );
@assert( true , generator.send( false ) === 4 );
@assert( true , generator.send( true ) === 5 );</code></pre>
			<p>このようにsendに値を与えると、<code>yield i</code> の部分が引数に置き換わります。</p>
			<p>iterator</p>
			<pre class="prettyprint grammars"><code>import {iterator} from "iterators";
var iter = {
      arr : [],
      add : function ( value ) {
        this.arr.push( value );
      },
      [iterator] : function () {
        var arr = this.arr;
        return {
          index : 0,
          next : function () {
            if ( arr.length > this.index ) {
              var ret = arr[ this.index ];
              this.index++;
              return ret;
            } else {
              throw StopIteration;
            }
          }
        }
      }
    }</code></pre>
	     <div>
		 <p class="title">詳細</p>
		 <p>この例のように、iteratorを生成するにはiteratorsモジュールのiteratorの値を、objectのプロパティにする必要があります。
ここで定義したiteratorはES Nextで追加されたfor of構文で使用されます。
詳しくはfor ofを参照してください。</p>
	     </div>
	    </div>
	</div>
	<div id="for-of" class="tab-pane">
	    <h3>for of</h3>
	    <p>for of構文とは、Generator、あるいはiteratorのnextを呼び出して値を列挙する構文です。</p>
	    <p>実装済み処理系 : なし</p>
	    <div>
		<pre class="prettyprint grammars"><code>import {iterator} from 'iterators';
var items = function ( obj ) {
      return {
        [iterator] : function () {
          for( var i in obj ) {
            yield [i, obj[i]];
          }
        }
      }
    },
    iter = {
      arr : [],
      add : function ( value ) {
        this.arr.push( value );
      },
      [iterator] : function () {
        var arr = this.arr;
        return {
          index : 0,
          next : function () {
            if ( arr.length > this.index ) {
              var ret = arr[ this.index ];
              this.index++;
              return ret;
            } else {
              throw StopIteration;
            }
          }
        }
      }
    }
    obj = {x:200,y:300}
for of(var i in items(obj)) {
  console.log(i[0], i[1]);
}
iter.add( 100 );
iter.add( 200 );
iter.add( 300 );
iter.add( 400 );
for of(var i in iter) {
  console.log(i);//100,200,300...
}</code></pre>
		<div class="section">
		    <p class="title">詳細</p>
		    <p>generatorかiteratorの定義されたオブジェクトを与えることで、次々にnextを呼び出し、StopIterationが投げられると処理を終了します。</p>
		</div>
	    </div>
	</div>
    </div>
</div>
