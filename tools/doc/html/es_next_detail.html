<div class="titile">
    <h2>Grammar Referrence</h2>
</div>
<div class="row">
    <div class="span4">
	<div class="tabbable tabs-left">
	    <ul class="nav nav-tabs grammar_list">
		<li class="active"><a data-toggle="tab" href="#class">class</a></li>
		<li><a data-toggle="tab" href="#trait">trait</a></li>
		<li><a data-toggle="tab" href="#destructuring-assignment">destructuring assignment</a></li>
		<li><a data-toggle="tab" href="#for-each">for each</a></li>
		<li><a data-toggle="tab" href="#do-expression">do expressions</a></li>
		<li><a data-toggle="tab" href="#short-function-syntax">short function syntax</a></li>
		<li><a data-toggle="tab" href="#import">import</a></li>
		<li><a data-toggle="tab" href="#module">module</a></li>
		<li><a data-toggle="tab" href="#let-expression">let expression</a></li>
		<li><a data-toggle="tab" href="#object-literal">object literal extras</a></li>
		<li><a data-toggle="tab" href="#data-structure-extras">data structur extras</a></li>
		<li><a data-toggle="tab" href="#generator-iterator">generator/iterator</a></li>
		<li><a data-toggle="tab" href="#for-of">for of</a></li>
	    </ul>
	</div>
</div>
<div class="span8">
    <div class="tab-content">
	<div id="class" class="tab-pane active">
	    <h3>class</h3>
	    <p>現在策定されているプロポーサルではclassが組み込まれる予定です。
		class機能自体はfunctionの糖衣構文になります。</p>
	    <p>実装済み処理系 : 無し</p>
	    <div>
		<p>まずは今までの書き方でクラスを生成してみます。</p>
		<pre class="prettyprint grammars"><code>//このクラスはTHREE.Meshを継承しています。
function SkinnedMesh(geometry, materials) {
  //親クラスのコンストラクタを呼び出します。
  THREE.Mesh.call(this, geometry, materials); 
  this.identityMatrix = new THREE.Matrix4();
  this.bones = [];
  this.boneMatrices = [];
};

//ecmascript5以降での継承です。
//THREE.Mesh.prototypeを継承したprototypeオブジェクトを生成します。
SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);
SkinnedMesh.prototype.constructor = SkinnedMesh;
SkinnedMesh.prototype.update = function(camera) {
  //親クラスのupdateメソッドの呼び出し。
  THREE.Mesh.prototype.update.call(this);
};</code></pre>
	    <p>次にES Nextで予定されているclassを使って書き換えてみます。</p>
	    <pre class="prettyprint grammars"><code>//継承を行うためにはclass 'drived' extends 'super'という構文を使う
//superはコンストラクタ関数か、クラスである必要がある
class SkinnedMesh extends THREE.Mesh {
  constructor(geometry, materials) {
    //親クラスのコンストラクタを呼び出す。
    //THREE.Mesh.call(this, geometry, materials)に該当
    super(geometry, materials);
    //publicなメンバはすべてpublic修飾子を宣言の前に付与する
    public identityMatrix = new THREE.Matrix4();
    public bones = [];
    public boneMatrices = [];
    ...
  }
  update(camera) {
    ...
    //親クラスのメソッド呼び出し。
    //THREE.Mesh.prototype.update.call(this)に該当
    super.update();
  }
}</code></pre>
		<p>次に基本的なクラスの構成要素の説明をします。</p>
		<pre class="prettyprint grammars"><code>class Monster {
  //コンストラクタは以下のように定義します。
  //クラスのメンバはコンストラクタ内で指定します。
  constructor(name, health) {
    public name = name;
    private health = health;
  }
  //クラスのメソッドはpublicかprivateのアクセス修飾が可能です。
  //指定しない場合はprivateになります。
  public attack(target) {
    log('The monster attacks ' + target);
  }
  //省略関数も利用可能です。
  //private修飾は本来の提案だとprivate(this).value
  //という形なのですが、無駄が多いので、一旦この形になっています。
  public isAlive -> private.health > 0;
  public health(value) {
    if (value < 0) {
      throw new Error('Health must be non-negative.')
    }
    private.health = value
  }
  //publicな関数以外のメンバはprototypenに設定され、
  //全てのインスタンスで共通の値が使用されます。
  public numAttacks = 0;
  //constなメンバはコンストラクタか、定義時に初期化しなければ
  //値の追加はできません。
  public const attackMessage = 'The monster hits you!';
  //static修飾が宣言されると変数はstaticな変数になります。
  //static修飾にはprivate,publicは設定できません。
  static const DEFAULT_LIFE = 100;
}</code></pre>
		<p>変換後は以下のようになります。</p>
		<pre class="prettyprint grammars"><code>var Monster = function () {
      function constructor(name,health) {
        this.name = name;
        Runtime.getPrivateRecord(this).health = health;
      }
      function Monster() {
        Runtime.initializeClass(this, Monster, _mochaPrivateHolder, constructor, arguments, "Monster", 1);
      }
      var _mochaPrivateHolder = function (){};
      
      Runtime.createUnenumProp(constructor,"__harmony_class__",1);
      
      Monster.prototype.attack = function (target) {
        log('The monster attacks '+target);
      };
      
      Monster.prototype.isAlive = function () {
        return Runtime.getPrivateRecord(this).health>0;
      };
      
      Monster.prototype.health = function (value) {
        if (value<0)throw new Error('Health must be non-negative.')
        
        Runtime.getPrivateRecord(this).health = value;
      };
      
      Monster.prototype.numAttacks = 0;
      
      Runtime.constant(Monster.prototype,'attackMessage','The monster hits you!');
      
      Runtime.constant(Monster,'DEFAULT_LIFE',100);
      
      Runtime.createUnenumProp(Monster.prototype,"constructor",constructor);
      return Monster;
    }()</code></pre>
			  <div class="section">
			      <p class="title">詳細</p>
			      <p>mochaではclassはコンストラクタ関数と、プロトタイプの糖衣構文として機能します。なので、既存のjavascriptのクラスと100%の互換性を持っています。またクラスを使用することによるオーバーヘッドもできるだけ抑えてありますが、privateフィールドの実現のためにやや実行時にオーバーヘッドがあります。</p>
			  </div>
			  <div class="section">
			      <p class="title">インターフェース</p>
			      <pre class="prettyprint grammars"><code><i>const(optional)</i> <i>class</i> &lt;class name&gt; <i>extends or prototype</i> &lt;base class name or literal&gt;</code></pre>
			      <p>
				  クラスを宣言します。class nameとbase class nameはjavascriptで使用可能な変数名を使用可能です。
		    const修飾子がついていた場合は、すべてのメンバが変更不可能になります。
		    継承の際にextendsを選ぶと、通常のプロトタイプの継承になります。prototypeを選ぶと、直接&lt;base class name or literal&gt;をprototypeとして使用します。
			      </p>
			      <pre class="prettyprint grammars"><code><i>constructor(</i>&lt;arguments list&gt;<i>)</i> &lt;function body&gt;</code></pre>
			      <p>
				  コンストラクタを定義します。コンストラクタは必ずconstructorという関数名でなければなりません。
				  メンバ変数の初期化を行います。コンストラクタが定義されていなければ、mochaが自動で空のコンストラクタを生成します。
			      </p>

			      <pre class="prettyprint grammars"><code><i>const(optional)</i> <i>public or private or static</i> &lt;name&gt; &lt;function body or '=' values&gt;(optional)</code></pre>
			      <p>
				  メンバを定義します。public修飾子がついていた場合はメンバは外部からアクセス可能になります。
				  const修飾子がついていた場合は、メンバは変更不可能になります。
				  private修飾子がついていた場合は、外部からアクセス不可なメンバになります。
				  何も修飾子を付けなかった場合は、デフォルトでprivateになります。
				  static修飾子が宣言された場合はメンバはインスタンス無しにアクセス可能になりますが、static以外のメンバにはアクセス出来ません。
				  またstaticなメンバはprivate、publicといったアクセス修飾は現在は出来ません。
			      </p>
			      <pre class="prettyprint grammars"><code><i>this.</i>&lt;name&gt;</code></pre>
			      <p>publicメンバにアクセスします。</p>
			      <pre class="prettyprint grammars"><code><i>private(object).</i>&lt;name&gt;</code></pre>
			      <p>privateメンバにアクセスします。</p>
			  </div>
	    </div>
	</div>
	<div id="trait" class="tab-pane">
	    <h3>trait</h3>
	    <p>クラスの振る舞いのみを定義したオブジェクトです。</p>
	    <p>実装済み処理系 : 無し</p>
	    <div>
		<p>traitの定義は以下のように行います。</p>
		<pre class="prettyprint grammars"><code>//traitの定義
trait TestTrait {
  requires testReq1;
  public test1( ...arg )->this.testReq1(arg[0]);
}
trait TestTrait2 {
  requires testReq2;
  public test1( ...arg )->this.testReq2(arg[0]);
  public test2->console.log('ok');
}
class MixinTest {
  public testReq1(arg) -> console.log(arg);
  public testReq2(arg) -> console.log(arg);
  mixin TestTrait with test1 as method1;
  mixin TestTrait2 without test1, with test2 as method2;
}</code></pre>
		<p>変換後は以下のようになります。</p>
		<pre class="prettyprint grammars"><code>var TestTrait =  {
        _mochaTraitPrivate : {},
        _mochaTraitPublic :  {
          test1 : function testm1() {
            var arg = Runtime.toArray(arguments,0);
            this.testReq1(arg[0]);
          }
        },
        _mochaRequires :  {
          testReq1 : true
        },
        _mochaTraitMark : true
      },
      TestTrait2 =  {
        _mochaTraitPrivate : {},
        _mochaTraitPublic :  {
          test1 : function testm2() {
            var arg = Runtime.toArray(arguments,0);
            this.testReq2(arg[0]);
          },
          test2 : function testm3() {
            console.log('ok');
          }
        },
        _mochaRequires :  {
          testReq2 : true
        },
        _mochaTraitMark : true
      },
      MixinTest = function () {
        function constructor(){}
        function MixinTest() {
          Runtime.initializeClass(this,MixinTest,_mochaPrivateHolder,constructor,arguments,'MixinTest',101);
        }
        var _mochaPrivateHolder = function (){};
        Runtime.createUnenumProp(constructor,"__harmony_class__",1);
        MixinTest.prototype.testReq1 = function (arg) {
          return console.log(arg)
        };
        MixinTest.prototype.testReq2 = function (arg) {
          return console.log(arg)
        };
        Runtime.classMixin(MixinTest,_mochaPrivateHolder,TestTrait, {
          test1 : "method1"
        },{});
        Runtime.classMixin(MixinTest,_mochaPrivateHolder,TestTrait2,{
          test2 : "method2"
        }, {
          test1 : true
        });
        Runtime.checkRequirements(MixinTest,_mochaPrivateHolder,[TestTrait,TestTrait2],'class_test.js',105);
        Runtime.createUnenumProp(MixinTest.prototype,"constructor",constructor);
        return MixinTest;
   }()</code></pre>
		<div class="section">
		    <p class="title">詳細</p>
		    <p>クラスに対して振る舞いを注入します。traitはrequireプロパティを設定することで実装しなければならないメソッドを指定できます。
またmixin属性を設定することで、trait同士、あるいはclassとtraitを合成可能です。その際にmixin ... with &lt;method_name&gt; as &lt:new_name&gt;とすることでメソッド名の書き換えが可能です。またwithout属性を指定することで、特定のメソッドのmixinを無効化することが可能です。
public,privateなどの指定はclassを参照してください。</p>
		</div>
		<div class="section">
		    <p class="title">インターフェース</p>
		    <pre class="prettyprint grammars"><code><i>trait</i> &lt;trait name&gt;</code></pre>
		    <p>traitを宣言します。</p>
		    <pre class="prettyprint grammars"><code><i>mixin</i> &lt;trait name&gt; <i>with(optional)</i> &lt;member name&gt; <i>as</i> &lt;new member name&gt <i>without(optional)</i> &lt;member name&gt;</code></pre>
		</div>
	    </div>
	</div>
	<div id="destructuring-assignment" class="tab-pane">
	    <h3>destructuring assignment</h3>
	    <p>分割代入機能です。</p>
	    <p>実装済み処理系 : mozilla 1.6以降</p>
	    <div>
		<p>配列</p>
		<pre class="prettyprint grammars"><code>var array = [0,1,2,3],
    [one,two,three,four] = array;
console.log(one,two,three,four);</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>var array = [0,1,2,3],
    one = array[0],
    two = array[1],
    three = array[2],
    four = array[3]</code></pre>
		<p>オブジェクト</p>
		<pre class="prettyprint grammars"><code>var obj = {
      one : 0,
      two : 1,
      three : 2,
      four : 3
    },
    {one,two,three,four} = obj;</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>var obj = {
      one : 0,
      two : 1,
      three : 2,
      four : 3
    },
    one = obj.one,
    two = obj.two,
    three = obj.three,
    four = obj.four;</code></pre>
		<p>少々複雑な例</p>
		<pre class="prettyprint grammars"><code>var object = {
      value1 : 100,
      value2 : {
        value3 : 100
      },
      value4 : [100,200,300],
      value5 : {
        value6 : [{value7 : 100}]
      },
      "@value" : {
        strvalue : 100
      }
    }
var {value1,value2:{ value3 },value4 : [ value5_,value6_,value7_ ],value5 : { value6 : [{value7}] },"@value":{strvalue}} = object;
		</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>var object = {
      value1 : 100,
      value2 : {
        value3 : 100
      },
      value4 : [100,200,300],
      value5 : {
        value6 : [{value7 : 100}]
      },
      "@value" : {
        strvalue : 100
      }
    },
    value1 = object.value1,
    value3 = object.value2 && object.value2.value3?object.value2.value3 : undefined,
    value5_ = object.value4 && object.value4[0]?object.value4[0] : undefined,
    value6_ = object.value4 && object.value4[1]?object.value4[1] : undefined,
    value7_ = object.value4 && object.value4[2]?object.value4[2] : undefined,
    value7 = object.value5 && object.value5.value6 && object.value5.value6[0] && object.value5.value6[0].value7?object.value5.value6[0].value7 : undefined,
    strvalue = object["@value"] && object["@value"].strvalue?object["@value"].strvalue : undefined;</code></pre>
	    </div>
	</div>
	<div id="for-each" class="tab-pane">
	    <h3>for each</h3>
	    <p>for each構文です。</p>
	    <p>実装済み処理系 : mozilla 1.6以降</p>
	    <div>
		<pre class="prettyprint grammars"><code>var obj = {a:1,b:2}
for each(var i in obj) {
  console.log(i);
}</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>var obj = {a:1,b:2}
for(var i in obj) {
  i = obj[i];
  console.log(i);
}</code></pre>
	    </div>
	</div>
	<div id="do-expression" class="tab-pane">
	    <h3>do expression</h3>
	    <p>簡易スコープです。</p>
	    <p>実装済み処理系 : なし</p>
	    <div>
		<pre class="prettyprint grammars"><code>var x = do { var t = f(); t * t + 1 };</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>var x = function () {
    var t = f();
    return t * t + 1;
}();</code></pre>
	    </div>
	</div>
	<div id="short-function-syntax" class="tab-pane">
	    <h3>short function syntax</h3>
	    <p>関数の短縮構文です。</p>
	    <p>実装済み処理系 : なし</p>
	    <div>
		<p>無名関数</p>
		<pre class="prettyprint grammars"><code>var a = (x,y,z) -> x + y + z,
    b = (x,y,z) -> { return x + y + z; }</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>var a = function (x,y,z) { return x + y + z;},
    b = function (x,y,z) { return x + y + z;}</code></pre>
		<p>関数宣言</p>
		<pre class="prettyprint grammars"><code>foo(x,y,z) -> x + y + z;
bar(x,y,z) -> { return x + y + z; }</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>function foo (x,y,z) { return x + y + z;}
function bar (x,y,z) { return x + y + z;}</code></pre>
		<p>コンテキストの束縛</p>
		<pre class="prettyprint grammars"><code>var a = (x,y,z) => x + y + z,
    b = (x,y,z) => { return x + y + z; }
foo(x,y,z) => console.log(this);
bar(x,y,z) => {console.log(this) }</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>var a = function (x,y,z) { return x + y + z; }.bind(this),
    b = function (x,y,z) { return x + y + z; }.bind(this);
function foo (x,y,z) { return console.log(_mochaLocalTmp0);}
foo = foo.bind(this);
function bar (x,y,z) { return console.log(_mochaLocalTmp1);}
bar = bar.bind(this);</code></pre>
	    </div>
	</div>
	<div id="import" class="tab-pane">
	    <h3>import</h3>
	    <p>モジュールのインポート機能です。</p>
	    <p>実装済み処理系 : なし</p>
	    <div>
		<pre class="prettyprint grammars"><code>import module from './test';
import {exports1,exports2} from './test2'.module;
import [value1, value2] from './test3'.module.exports;
import exports from './test4'.module;
import './test5' as test5</code></pre>
		<p>変換後</p>
		<pre class="prettyprint grammars"><code>var module = Runtime.modules.get('349045-test.js').module,
    _mochaLocalTmp0 = Runtime.modules.get('564059-test2.js').module,
    exports1 = _mochaLocalTmp0.exports1,
    exports2 = _mochaLocalTmp0.exports2,
    _mochaLocalTmp1 = Runtime.modules.get('906045-test3.js').module.exports,
    value1 = _mochaLocalTmp1[0],
    value2 = _mochaLocalTmp1[1],
    exports = Runtime.modules.get('945095-test4.js').module.exports,
    test5 = Runtime.modules.get('455905-test5.js');
    </code></pre>
		<div class="section">
		    <p class="title">詳細</p>
		    <p>importのルール</p>
		    <p>ファイルのインポートは以下のルールに沿って行われます。</p>
		    <table>
			<tr>
			    <th>記述</th><th>説明</th>
			</tr>
			<tr>
			    <td>'./filename'</td><td>現在のファイルがあるディレクトリから探します。</td>
			</tr>
			<tr>
			    <td>'filename'</td><td>ランタイムモジュール、あるいはoptionのmoduleDirプロパティから探します。</td>
			</tr>
		    </table>
		</div>
	    </div>
	</div>
    </div>
</div>
